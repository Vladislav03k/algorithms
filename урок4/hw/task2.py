# Взята 3 задача из 2 урока:
# Сформировать из введенного числа обратное по порядку входящих в него цифр и вывести на экран.
# Например, если введено число 3486, надо вывести 6843.

# Условие задачи было мной модифицировано (фактически с числами это работает также, не учтено только окончание числа
# на 0, делается это 2 строчками кода через if - если что я знаю, как это делается):
# Сделать реверс любой строки, приведенной на вход.

import cProfile


# Первая версия (изначальная)
def reverse_1(string, length, s):
    if length == 0:
        return s
    else:
        count = 1
        for let in string:
            if count == length:
                s += let
                length -= 1
                return reverse_1(string, length, s)
            else:
                count += 1


# Вторая версия (без рекурсии, с использованием индексов, но без срезов)
def reverse_2(string):
    s = ''
    ind = len(string)
    for i in range(ind - 1, -1, -1):
        s += string[i]
    return s


# Третья версия (максимальные возможности питона - использование срезов)
def reverse_3(string):
    return string[::-1]


# string = '123456789' * 100
# cProfile.run('reverse_1(string, len(string), "")')

# cProfile.run("reverse_2('123456789' * 100)")

# cProfile.run("reverse_3('123456789' * 100)")

# Для копирования в терминал
# python -m timeit -n 100 -s "import les_4_task_1" "les_4_task_1.reverse_1('123456789'*100, len('123456789'*1
# 00), '')"

# Результаты первой версии
# 100 loops, best of 5: 35.2 msec per loop
# 901/1    0.035    0.000    0.035    0.035 les_4_task_1.py:23(reverse_1)

# Сложность первого алгоритма по моему мнению минимум - O(2^n). Возможно O(n*2^n).

# Для копирования в терминал
# python -m timeit -n 100 -s "import les_4_task_1" "les_4_task_1.reverse_2('123456789'*100)"

# Результаты второй версии
# 100 loops, best of 5: 156 usec per loop
# 1    0.000    0.000    0.000    0.000 les_4_task_1.py:38(reverse_2)

# Сложность второго алгоритма по моему мнению - O(n^2). Так как O(n) занимает проход по массиу и столько же занимает
# конкатенация строк (в python это постоянное создание новой строки на основе двух предыдущих)

# Для копирования в терминал
# python -m timeit -n 100 -s "import les_4_task_1" "les_4_task_1.reverse_3('123456789'*100)"

# Результаты третьей версии
# 100 loops, best of 5: 2.72 usec per loop
# 1    0.000    0.000    0.000    0.000 les_4_task_1.py:47(reverse_3)

# Сложность третьего алгоритма - O(n)